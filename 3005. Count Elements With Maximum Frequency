You are given an array nums consisting of positive integers.

Return the total frequencies of elements in nums such that those elements all have the maximum frequency.

The frequency of an element is the number of occurrences of that element in the array.

 

Example 1:

Input: nums = [1,2,2,3,1,4]
Output: 4
Explanation: The elements 1 and 2 have a frequency of 2 which is the maximum frequency in the array.
So the number of elements in the array with maximum frequency is 4.
Example 2:

Input: nums = [1,2,3,4,5]
Output: 5
Explanation: All elements of the array have a frequency of 1 which is the maximum.
So the number of elements in the array with maximum frequency is 5.
 

Constraints:

1 <= nums.length <= 100
1 <= nums[i] <= 100

--------------------------------------------

Given the constraints:

The maximum element, and frequency is 100.
So, instead of Hash map, we only need to use an array of length 100+1.
Also, 100 can be easily contained in an 8-bit integer.
Algorithm
anigif.gif

Iterate through nums while maintaining a frequency count for each element.

Track the current maximum frequency max.

For each element:

Increment its frequency.
If the new frequency exceeds max, update max and set res to this frequency.
If the new frequency equals max, add it to res.
Using an 8-bit integer for frequencies reduces memory usage.

Complexity
Time complexity: O(n)
Space complexity: O(1)



---------------------------------------------------


class Solution {
    public int maxFrequencyElements(int[] nums) {
        byte[] freq = new byte[101];
        byte max = 0, res = 0;
        for (int n : nums) {
            byte f = ++freq[n];
            if (f > max) {
                max = f; res = f;
            } else if (f == max) 
                res += f;
        }
        return res;
    }
}
