You are given an array of n strings strs, all of the same length.

We may choose any deletion indices, and we delete all the characters in those indices for each string.

For example, if we have strs = ["abcdef","uvwxyz"] and deletion indices {0, 2, 3}, then the final array after deletions is ["bef", "vyz"].

Suppose we chose a set of deletion indices answer such that after deletions, the final array has its elements in lexicographic order (i.e., strs[0] <= strs[1] <= strs[2] <= ... <= strs[n - 1]). Return the minimum possible value of answer.length.

 

Example 1:

Input: strs = ["ca","bb","ac"]
Output: 1
Explanation: 
After deleting the first column, strs = ["a", "b", "c"].
Now strs is in lexicographic order (ie. strs[0] <= strs[1] <= strs[2]).
We require at least 1 deletion since initially strs was not in lexicographic order, so the answer is 1.
Example 2:

Input: strs = ["xc","yb","za"]
Output: 0
Explanation: 
strs is already in lexicographic order, so we do not need to delete anything.
Note that the rows of strs are not necessarily in lexicographic order:
i.e., it is NOT necessarily true that (strs[0][0] <= strs[0][1] <= ...)
Example 3:

Input: strs = ["zyx","wvu","tsr"]
Output: 3
Explanation: We have to delete every column.
 

Constraints:

n == strs.length
1 <= n <= 100
1 <= strs[i].length <= 100
strs[i] consists of lowercase English letters.
 


-------------------------------------------


The main challenge in sorting strings is that a later column only matters if all previous columns were identical for a pair of strings. 
This code flips that logic: instead of checking if strings are identical, it tracks if they are already definitively sorted. 
Key Mechanics Greedy Deletion: The algorithm assumes every column is useful until proven otherwise. 
If a column contains even one "bad" pair (where a lexicographically larger character appears above a smaller one in a pair not yet sorted), the entire column must be deleted.
It is never beneficial to keep a column that breaks the existing order.Progressive Sorting (sorted[] array): This array acts as a memory of "resolved" rows.If sorted[i] is true, it means the string at row i-1 is already strictly smaller than the string at row i because of a character in a previous column.
Once a pair is resolved, their characters in all future columns are ignored, as they cannot change the already-established order of those two strings.Irreversibility: Once a column is kept and new rows are marked as "sorted," that decision is final. 
This ensures the algorithm stays efficient at \(O(M\times N)\) time complexity. Why This Works By keeping only columns that do not violate the order of "unresolved" pairs, you naturally build the lexicographical sequence from left to right. Using a boolean array to skip already-sorted pairs ensures that you only delete a column when it is absolutely necessary to fix a remaining conflict. 

-------------------------------

class Solution {
    public int minDeletionSize(String[] strs) {
        int m = strs.length, n = strs[0].length(), res = 0;
        boolean[] sorted = new boolean[m];
        
        search: for (int j = 0; j < n; j++) {
            for (int i = 1; i < m; i++) 
                if (!sorted[i] && strs[i-1].charAt(j) > strs[i].charAt(j)) {
                    res++; continue search;
                }
            
            for (int i = 1; i < m; i++) 
                if (strs[i-1].charAt(j) < strs[i].charAt(j)) sorted[i] = true;
        }
        return res;
    }
}



