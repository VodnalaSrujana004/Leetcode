You are given a directed, weighted graph with n nodes labeled from 0 to n - 1, and an array edges where edges[i] = [ui, vi, wi] represents a directed edge from node ui to node vi with cost wi.

Each node ui has a switch that can be used at most once: when you arrive at ui and have not yet used its switch, you may activate it on one of its incoming edges vi → ui reverse that edge to ui → vi and immediately traverse it.

The reversal is only valid for that single move, and using a reversed edge costs 2 * wi.

Return the minimum total cost to travel from node 0 to node n - 1. If it is not possible, return -1.

 

Example 1:

Input: n = 4, edges = [[0,1,3],[3,1,1],[2,3,4],[0,2,2]]

Output: 5

Explanation:



Use the path 0 → 1 (cost 3).
At node 1 reverse the original edge 3 → 1 into 1 → 3 and traverse it at cost 2 * 1 = 2.
Total cost is 3 + 2 = 5.
Example 2:

Input: n = 4, edges = [[0,2,1],[2,1,1],[1,3,1],[2,3,3]]

Output: 3

Explanation:

No reversal is needed. Take the path 0 → 2 (cost 1), then 2 → 1 (cost 1), then 1 → 3 (cost 1).
Total cost is 1 + 1 + 1 = 3.
 

Constraints:

2 <= n <= 5 * 104
1 <= edges.length <= 105
edges[i] = [ui, vi, wi]
0 <= ui, vi <= n - 1
1 <= wi <= 1000

--------------------------

class Solution {
    public int minCost(int n, int[][] edges) {
        ArrayList<int[]>[] adj = new ArrayList[n];
        for(int i = 0;i < n;i++) adj[i] = new ArrayList<>();

        for(int[] edge: edges) {
            adj[edge[0]].add(new int[]{edge[1], edge[2]});
            adj[edge[1]].add(new int[]{edge[0], 2*edge[2]});
        }

        int[] rch = new int[n];
        Arrays.fill(rch, Integer.MAX_VALUE);
        PriorityQueue<int[]> pq = new PriorityQueue<>((a,b)->a[1]-b[1]);
        pq.offer(new int[]{0, 0});
        rch[0] = 0;

        while(!pq.isEmpty()) {
            int[] cur = pq.poll();
            int nd = cur[0];
            int curWg = cur[1];
            
            if(curWg > rch[nd]) continue;
            for(int[] nxt: adj[nd]) {
                int tmpWe = nxt[1]+curWg;
                if(rch[nxt[0]] > tmpWe){
                    rch[nxt[0]] = tmpWe;
                    pq.offer(new int[]{nxt[0], tmpWe});
                }
            }
        }
        
        return rch[n-1] == Integer.MAX_VALUE ? -1: rch[n-1];
    }
}
