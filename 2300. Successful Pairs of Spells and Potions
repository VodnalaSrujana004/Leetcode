You are given two positive integer arrays spells and potions, of length n and m respectively, where spells[i] represents the strength of the ith spell and potions[j] represents the strength of the jth potion.

You are also given an integer success. A spell and potion pair is considered successful if the product of their strengths is at least success.

Return an integer array pairs of length n where pairs[i] is the number of potions that will form a successful pair with the ith spell.

 

Example 1:

Input: spells = [5,1,3], potions = [1,2,3,4,5], success = 7
Output: [4,0,3]
Explanation:
- 0th spell: 5 * [1,2,3,4,5] = [5,10,15,20,25]. 4 pairs are successful.
- 1st spell: 1 * [1,2,3,4,5] = [1,2,3,4,5]. 0 pairs are successful.
- 2nd spell: 3 * [1,2,3,4,5] = [3,6,9,12,15]. 3 pairs are successful.
Thus, [4,0,3] is returned.
Example 2:

Input: spells = [3,1,2], potions = [8,5,8], success = 16
Output: [2,0,2]
Explanation:
- 0th spell: 3 * [8,5,8] = [24,15,24]. 2 pairs are successful.
- 1st spell: 1 * [8,5,8] = [8,5,8]. 0 pairs are successful. 
- 2nd spell: 2 * [8,5,8] = [16,10,16]. 2 pairs are successful. 
Thus, [2,0,2] is returned.
 

Constraints:

n == spells.length
m == potions.length
1 <= n, m <= 105
1 <= spells[i], potions[i] <= 105
1 <= success <= 1010



-----------------------------------------------------------



ðŸ§  Intuition
Each spell needs to be paired with potions such that the product of their strengths is at least success.
For a fixed spell, as potion strength increases, the product also increases.
Thus, for a sorted potion list, once we find the first potion that satisfies the condition, all stronger potions will also work.
This naturally suggests a binary search approach.

ðŸš€ Approach
Sort the potions array in non-decreasing order.

For each spell:

Use binary search on potions to find the lowest index i where
spell * potions[i] >= success.

The number of successful pairs for that spell = n - i (where n is the number of potions).

Store this count in the answer array.

Return the result array after processing all spells.

This approach ensures we efficiently find the number of successful potions for every spell.

Complexity
Time complexity: O((m + n) log n)
Sorting potions takes O(n log n)
For each spell (m total), binary search takes O(log n)

Space complexity: O(1)
We only use extra space for the result array â†’ O(1) auxiliary, or O(m) total including output.



----------------------------------------------------------------------------------------------------



class Solution {
    public int[] successfulPairs(int[] spells, int[] potions, long success) {
        Arrays.sort(potions);
        int n = potions.length;
        int[] ans = new int[spells.length];

        for (int i = 0; i < spells.length; i++) {
            int low = 0, high = n - 1;
            while (low <= high) {
                int mid = low + (high - low) / 2;
                if ((long) spells[i] * potions[mid] >= success)
                    high = mid - 1;
                else
                    low = mid + 1;
            }
            ans[i] = n - low;
        }

        return ans;
    }
}
