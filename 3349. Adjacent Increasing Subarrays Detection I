Given an array nums of n integers and an integer k, determine whether there exist two adjacent subarrays of length k such that both subarrays are strictly increasing. Specifically, check if there are two subarrays starting at indices a and b (a < b), where:

Both subarrays nums[a..a + k - 1] and nums[b..b + k - 1] are strictly increasing.
The subarrays must be adjacent, meaning b = a + k.
Return true if it is possible to find two such subarrays, and false otherwise.

 

Example 1:

Input: nums = [2,5,7,8,9,2,3,4,3,1], k = 3

Output: true

Explanation:

The subarray starting at index 2 is [7, 8, 9], which is strictly increasing.
The subarray starting at index 5 is [2, 3, 4], which is also strictly increasing.
These two subarrays are adjacent, so the result is true.
Example 2:

Input: nums = [1,2,3,4,4,4,4,5,6,7], k = 5

Output: false

 

Constraints:

2 <= nums.length <= 100
1 < 2 * k <= nums.length
-1000 <= nums[i] <= 1000

-------------------------------------------------------------------------


Intuition
We need to determine if there exist two adjacent subarrays of length k that are both strictly increasing.
Instead of checking every possible subarray separately, we can track the lengths of increasing runs as we traverse the array.
If two consecutive increasing runs each have length at least k, then such subarrays exist.

Approach
Use two counters:
inc → length of the current strictly increasing run.
prevInc → length of the previous increasing run.
Traverse the array:
If nums[i] > nums[i - 1], increment inc.
Otherwise, assign prevInc = inc and reset inc = 1.
After each update, check if both the previous and current runs can form subarrays of size k.
This is true if min(prevInc, inc) >= k.
If found, return true. Otherwise, continue until the end and return false.
Complexity
Time complexity: O(N)
Space complexity: O(1)

------------------------------------------------------------------------


public class Solution {
    public boolean hasIncreasingSubarrays(List<Integer> nums, int k) {
        int n = nums.size();
        int inc = 1, prevInc = 0, maxLen = 0;
        for (int i = 1; i < n; i++) {
            if (nums.get(i) > nums.get(i - 1)) inc++;
            else {
                prevInc = inc;
                inc = 1;
            }
            maxLen = Math.max(maxLen, Math.max(inc >> 1, Math.min(prevInc, inc)));
            if (maxLen >= k) return true;
        }
        return false;
    }
}
