You are given two 0-indexed strings source and target, both of length n and consisting of lowercase English characters. You are also given two 0-indexed string arrays original and changed, and an integer array cost, where cost[i] represents the cost of converting the string original[i] to the string changed[i].

You start with the string source. In one operation, you can pick a substring x from the string, and change it to y at a cost of z if there exists any index j such that cost[j] == z, original[j] == x, and changed[j] == y. You are allowed to do any number of operations, but any pair of operations must satisfy either of these two conditions:

The substrings picked in the operations are source[a..b] and source[c..d] with either b < c or d < a. In other words, the indices picked in both operations are disjoint.
The substrings picked in the operations are source[a..b] and source[c..d] with a == c and b == d. In other words, the indices picked in both operations are identical.
Return the minimum cost to convert the string source to the string target using any number of operations. If it is impossible to convert source to target, return -1.

Note that there may exist indices i, j such that original[j] == original[i] and changed[j] == changed[i].

 

Example 1:

Input: source = "abcd", target = "acbe", original = ["a","b","c","c","e","d"], changed = ["b","c","b","e","b","e"], cost = [2,5,5,1,2,20]
Output: 28
Explanation: To convert "abcd" to "acbe", do the following operations:
- Change substring source[1..1] from "b" to "c" at a cost of 5.
- Change substring source[2..2] from "c" to "e" at a cost of 1.
- Change substring source[2..2] from "e" to "b" at a cost of 2.
- Change substring source[3..3] from "d" to "e" at a cost of 20.
The total cost incurred is 5 + 1 + 2 + 20 = 28. 
It can be shown that this is the minimum possible cost.
Example 2:

Input: source = "abcdefgh", target = "acdeeghh", original = ["bcd","fgh","thh"], changed = ["cde","thh","ghh"], cost = [1,3,5]
Output: 9
Explanation: To convert "abcdefgh" to "acdeeghh", do the following operations:
- Change substring source[1..3] from "bcd" to "cde" at a cost of 1.
- Change substring source[5..7] from "fgh" to "thh" at a cost of 3. We can do this operation because indices [5,7] are disjoint with indices picked in the first operation.
- Change substring source[5..7] from "thh" to "ghh" at a cost of 5. We can do this operation because indices [5,7] are disjoint with indices picked in the first operation, and identical with indices picked in the second operation.
The total cost incurred is 1 + 3 + 5 = 9.
It can be shown that this is the minimum possible cost.
Example 3:

Input: source = "abcdefgh", target = "addddddd", original = ["bcd","defgh"], changed = ["ddd","ddddd"], cost = [100,1578]
Output: -1
Explanation: It is impossible to convert "abcdefgh" to "addddddd".
If you select substring source[1..3] as the first operation to change "abcdefgh" to "adddefgh", you cannot select substring source[3..7] as the second operation because it has a common index, 3, with the first operation.
If you select substring source[3..7] as the first operation to change "abcdefgh" to "abcddddd", you cannot select substring source[1..3] as the second operation because it has a common index, 3, with the first operation.
 

Constraints:

1 <= source.length == target.length <= 1000
source, target consist only of lowercase English characters.
1 <= cost.length == original.length == changed.length <= 100
1 <= original[i].length == changed[i].length <= source.length
original[i], changed[i] consist only of lowercase English characters.
original[i] != changed[i]
1 <= cost[i] <= 106
----------------------------------------------


import java.util.Arrays;
import java.util.HashMap;
import java.util.Map;

class Solution {
    
    // Simple Trie Node class
    private static class TrieNode {
        TrieNode[] next = new TrieNode[26];
        int id = -1; // Stores the graph ID (0..V-1) if a string ends here
    }

    public long minimumCost(String source, String target, String[] original, String[] changed, int[] cost) {
        int n = source.length();
        
        // 1. Map all unique strings to integer IDs
        // We need this to build the adjacency matrix for the graph
        Map<String, Integer> strToId = new HashMap<>();
        int idCounter = 0;
        
        for (String s : original) {
            if (!strToId.containsKey(s)) strToId.put(s, idCounter++);
        }
        for (String s : changed) {
            if (!strToId.containsKey(s)) strToId.put(s, idCounter++);
        }
        
        int numNodes = strToId.size();
        
        // 2. Build the Cost Graph (Adjacency Matrix)
        long[][] dist = new long[numNodes][numNodes];
        long INF = Long.MAX_VALUE / 2;
        
        for (long[] row : dist) Arrays.fill(row, INF);
        for (int i = 0; i < numNodes; i++) dist[i][i] = 0;
        
        for (int i = 0; i < original.length; i++) {
            int u = strToId.get(original[i]);
            int v = strToId.get(changed[i]);
            dist[u][v] = Math.min(dist[u][v], cost[i]);
        }
        
        // 3. Floyd-Warshall Algorithm for All-Pairs Shortest Path
        // O(V^3), where V <= 200. Very fast (~8M ops max).
        for (int k = 0; k < numNodes; k++) {
            for (int i = 0; i < numNodes; i++) {
                if (dist[i][k] == INF) continue;
                for (int j = 0; j < numNodes; j++) {
                    if (dist[k][j] < INF) {
                        dist[i][j] = Math.min(dist[i][j], dist[i][k] + dist[k][j]);
                    }
                }
            }
        }
        
        // 4. Build Trie with ALL unique strings
        // This lets us match both 'original' substrings and 'changed' substrings efficiently.
        TrieNode root = new TrieNode();
        for (Map.Entry<String, Integer> entry : strToId.entrySet()) {
            String s = entry.getKey();
            int id = entry.getValue();
            TrieNode node = root;
            for (int i = 0; i < s.length(); i++) {
                int c = s.charAt(i) - 'a';
                if (node.next[c] == null) node.next[c] = new TrieNode();
                node = node.next[c];
            }
            node.id = id;
        }
        
        // 5. Dynamic Programming
        long[] dp = new long[n + 1];
        Arrays.fill(dp, INF);
        dp[0] = 0;
        
        char[] sChars = source.toCharArray();
        char[] tChars = target.toCharArray();
        
        for (int i = 0; i < n; i++) {
            if (dp[i] == INF) continue;
            
            // Optimization: If characters match, skip with cost 0
            if (sChars[i] == tChars[i]) {
                dp[i + 1] = Math.min(dp[i + 1], dp[i]);
            }
            
            // Try to match substrings using Simultaneous Trie Traversal
            // We traverse using source[i...] AND target[i...] at the same time.
            TrieNode pSource = root;
            TrieNode pTarget = root;
            
            for (int j = i; j < n; j++) {
                int c1 = sChars[j] - 'a';
                int c2 = tChars[j] - 'a';
                
                pSource = pSource.next[c1];
                pTarget = pTarget.next[c2];
                
                // If either path doesn't exist in the Trie, we can't form a known string
                if (pSource == null || pTarget == null) break;
                
                // If both pointers land on valid string IDs, check the cost
                if (pSource.id != -1 && pTarget.id != -1) {
                    long costVal = dist[pSource.id][pTarget.id];
                    if (costVal < INF) {
                        dp[j + 1] = Math.min(dp[j + 1], dp[i] + costVal);
                    }
                }
            }
        }
        
        return dp[n] == INF ? -1 : dp[n];
    }
}
